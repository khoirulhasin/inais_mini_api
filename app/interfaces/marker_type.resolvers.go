package interfaces

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"

	"github.com/google/uuid"
	"github.com/khoirulhasin/untirta_api/app/infrastructures/error_handlers"
	"github.com/khoirulhasin/untirta_api/app/infrastructures/pkg"
	"github.com/khoirulhasin/untirta_api/app/models"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// CreateMarkerType is the resolver for the CreateMarkerType field.
func (r *mutationResolver) CreateMarkerType(ctx context.Context, createMarkerTypeInput models.CreateMarkerTypeInput) (any, error) {
	role := &models.MarkerType{
		Name: createMarkerTypeInput.Name,
		Icon: createMarkerTypeInput.Icon,
	}
	response, err := r.MarkerTypeRepository.CreateMarkerType(ctx, role)

	if err != nil {
		return nil, gqlerror.Errorf(error_handlers.ParsePGError(err))
	}

	return response, nil
}

// UpdateMarkerType is the resolver for the UpdateMarkerType field.
func (r *mutationResolver) UpdateMarkerType(ctx context.Context, id int, updateMarkerTypeInput models.UpdateMarkerTypeInput) (any, error) {
	role := &models.MarkerType{
		Name: updateMarkerTypeInput.Name,
		Icon: updateMarkerTypeInput.Icon,
	}

	response, err := r.MarkerTypeRepository.UpdateMarkerType(ctx, int32(id), role)

	if err != nil {
		return nil, gqlerror.Errorf(error_handlers.ParsePGError(err))
	}

	return response, nil
}

// UpdateMarkerTypeByUUID is the resolver for the UpdateMarkerTypeByUuid field.
func (r *mutationResolver) UpdateMarkerTypeByUUID(ctx context.Context, uuid uuid.UUID, updateMarkerTypeInput *models.UpdateMarkerTypeInput) (any, error) {
	role := &models.MarkerType{
		Name: updateMarkerTypeInput.Name,
		Icon: updateMarkerTypeInput.Icon,
	}

	response, err := r.MarkerTypeRepository.UpdateMarkerTypeByUUID(ctx, uuid.String(), role)

	if err != nil {
		return nil, gqlerror.Errorf(error_handlers.ParsePGError(err))
	}

	return response, nil
}

// DeleteMarkerType is the resolver for the DeleteMarkerType field.
func (r *mutationResolver) DeleteMarkerType(ctx context.Context, id int) (any, error) {
	err := r.MarkerTypeRepository.DeleteMarkerType(ctx, int32(id))

	if err != nil {
		return nil, gqlerror.Errorf(error_handlers.ParsePGError(err))
	}

	return nil, nil
}

// DeleteMarkerTypeByUUID is the resolver for the DeleteMarkerTypeByUuid field.
func (r *mutationResolver) DeleteMarkerTypeByUUID(ctx context.Context, uuid uuid.UUID) (any, error) {
	err := r.MarkerTypeRepository.DeleteMarkerTypeByUUID(ctx, uuid.String())

	if err != nil {
		return nil, gqlerror.Errorf(error_handlers.ParsePGError(err))
	}

	return nil, nil
}

// GetOneMarkerType is the resolver for the GetOneMarkerType field.
func (r *queryResolver) GetOneMarkerType(ctx context.Context, id int) (any, error) {
	role, err := r.MarkerTypeRepository.GetMarkerTypeByID(ctx, int32(id))

	if err != nil {
		return nil, gqlerror.Errorf(error_handlers.ParsePGError(err))
	}

	return role, nil
}

// GetOneMarkerTypeByUUID is the resolver for the GetOneMarkerTypeByUuid field.
func (r *queryResolver) GetOneMarkerTypeByUUID(ctx context.Context, uuid uuid.UUID) (any, error) {
	role, err := r.MarkerTypeRepository.GetMarkerTypeByUUID(ctx, uuid.String())

	if err != nil {
		return nil, gqlerror.Errorf(error_handlers.ParsePGError(err))
	}

	return role, nil
}

// GetAllMarkerTypes is the resolver for the GetAllMarkerTypes field.
func (r *queryResolver) GetAllMarkerTypes(ctx context.Context) ([]any, error) {
	roles, err := r.MarkerTypeRepository.GetAllMarkerTypes(ctx)

	if err != nil {
		return nil, gqlerror.Errorf(error_handlers.ParsePGError(err))
	}

	response := make([]any, len(roles))
	for i, role := range roles {
		response[i] = role
	}

	return response, nil
}

// PageMarkerType is the resolver for the PageMarkerType field.
func (r *queryResolver) PageMarkerType(ctx context.Context, pageInput *models.PageInput) (*models.Pagination, error) {
	limit, offset, sortField, sortOrder, search, _ := pkg.PageInputIsNil(pageInput)

	pagination := models.Pagination{
		Limit:     &limit,
		Offset:    &offset,
		SortField: &sortField,
		SortOrder: &sortOrder,
		Search:    &search,
	}

	response, err := r.MarkerTypeRepository.PageMarkerType(ctx, pagination)

	if err != nil {
		return nil, gqlerror.Errorf(error_handlers.ParsePGError(err))
	}

	return &response, nil
}
