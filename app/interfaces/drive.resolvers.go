package interfaces

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"

	"github.com/google/uuid"
	"github.com/khoirulhasin/untirta_api/app/infrastructures/error_handlers"
	"github.com/khoirulhasin/untirta_api/app/infrastructures/pkg"
	"github.com/khoirulhasin/untirta_api/app/models"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// CreateDrive is the resolver for the CreateDrive field.
func (r *mutationResolver) CreateDrive(ctx context.Context, createDriveInput models.CreateDriveInput) (any, error) {
	drive := &models.Drive{
		DriverID:    createDriveInput.DriverID,
		ShipID:      createDriveInput.ShipID,
		Description: createDriveInput.Description,
	}
	response, err := r.DriveRepository.CreateDrive(ctx, drive)

	if err != nil {
		return nil, gqlerror.Errorf(error_handlers.ParsePGError(err))
	}

	return response, nil
}

// UpdateDrive is the resolver for the UpdateDrive field.
func (r *mutationResolver) UpdateDrive(ctx context.Context, id int, updateDriveInput models.UpdateDriveInput) (any, error) {
	drive := &models.Drive{
		DriverID:    updateDriveInput.DriverID,
		ShipID:      updateDriveInput.ShipID,
		Description: updateDriveInput.Description,
	}

	response, err := r.DriveRepository.UpdateDrive(ctx, int32(id), drive)

	if err != nil {
		return nil, gqlerror.Errorf(error_handlers.ParsePGError(err))
	}

	return response, nil
}

// UpdateDriveByUUID is the resolver for the UpdateDriveByUuid field.
func (r *mutationResolver) UpdateDriveByUUID(ctx context.Context, uuid uuid.UUID, updateDriveInput models.UpdateDriveInput) (any, error) {
	drive := &models.Drive{
		DriverID:    updateDriveInput.ShipID,
		ShipID:      updateDriveInput.ShipID,
		Description: updateDriveInput.Description,
	}

	response, err := r.DriveRepository.UpdateDriveByUUID(ctx, uuid.String(), drive)

	if err != nil {
		return nil, gqlerror.Errorf(error_handlers.ParsePGError(err))
	}

	return response, nil
}

// DeleteDrive is the resolver for the DeleteDrive field.
func (r *mutationResolver) DeleteDrive(ctx context.Context, id int) (any, error) {
	err := r.DriveRepository.DeleteDrive(ctx, int32(id))

	if err != nil {
		return nil, gqlerror.Errorf(error_handlers.ParsePGError(err))
	}

	return nil, nil
}

// DeleteDriveByUUID is the resolver for the DeleteDriveByUuid field.
func (r *mutationResolver) DeleteDriveByUUID(ctx context.Context, uuid uuid.UUID) (any, error) {
	err := r.DriveRepository.DeleteDriveByUUID(ctx, uuid.String())

	if err != nil {
		return nil, gqlerror.Errorf(error_handlers.ParsePGError(err))
	}

	return nil, nil
}

// GetOneDrive is the resolver for the GetOneDrive field.
func (r *queryResolver) GetOneDrive(ctx context.Context, id int) (any, error) {
	drive, err := r.DriveRepository.GetDriveByID(ctx, int32(id))

	if err != nil {
		return nil, gqlerror.Errorf(error_handlers.ParsePGError(err))
	}

	return drive, nil
}

// GetOneDriveByUUID is the resolver for the GetOneDriveByUuid field.
func (r *queryResolver) GetOneDriveByUUID(ctx context.Context, uuid uuid.UUID) (any, error) {
	drive, err := r.DriveRepository.GetDriveByUUID(ctx, uuid.String())

	if err != nil {
		return nil, gqlerror.Errorf(error_handlers.ParsePGError(err))
	}

	return drive, nil
}

// GetAllDrives is the resolver for the GetAllDrives field.
func (r *queryResolver) GetAllDrives(ctx context.Context) ([]any, error) {
	drives, err := r.DriveRepository.GetAllDrives(ctx)

	if err != nil {
		return nil, gqlerror.Errorf(error_handlers.ParsePGError(err))
	}

	response := make([]any, len(drives))
	for i, drive := range drives {
		response[i] = drive
	}

	return response, nil
}

// PageDrive is the resolver for the PageDrive field.
func (r *queryResolver) PageDrive(ctx context.Context, pageInput *models.PageInput) (*models.Pagination, error) {
	limit, offset, sortField, sortOrder, search, _ := pkg.PageInputIsNil(pageInput)

	pagination := models.Pagination{
		Limit:     &limit,
		Offset:    &offset,
		SortField: &sortField,
		SortOrder: &sortOrder,
		Search:    &search,
	}

	response, err := r.DriveRepository.PageDrive(ctx, pagination)

	if err != nil {
		return nil, gqlerror.Errorf(error_handlers.ParsePGError(err))
	}

	return &response, nil
}
