package interfaces

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/khoirulhasin/globe_tracker_api/app/generated"
	"github.com/khoirulhasin/globe_tracker_api/app/infrastructures/error_handlers"
	"github.com/khoirulhasin/globe_tracker_api/app/models"
	"github.com/khoirulhasin/globe_tracker_api/helpers"
)

// CreateQuestion is the resolver for the CreateQuestion field.
func (r *mutationResolver) CreateQuestion(ctx context.Context, question models.QuestionInput) (*models.Response, error) {
	gc, _ := helpers.GinContextFromContext(ctx)
	error_handlers.PanicHandler(gc)
	//validate the title:
	if question.Title == "" {
		return &models.Response{
			Message: "The title is required",
			Status:  http.StatusBadRequest,
		}, nil
	}

	ques := &models.Question{
		Title: question.Title,
	}

	ques.CreatedAt = time.Now()
	ques.UpdatedAt = time.Now()

	//save the question:
	quest, err := r.QuestionRepository.CreateQuestion(ques)
	if err != nil {
		fmt.Println("the error with this: ", err)
		return &models.Response{
			Message: err.Error(),
			Status:  http.StatusInternalServerError,
		}, nil
	}

	//validate the question options:
	for _, v := range question.Options {

		if ok, errorString := helpers.ValidateInputs(*v); !ok {
			return &models.Response{
				Message: errorString,
				Status:  http.StatusUnprocessableEntity,
			}, nil
		}

		quesOpt := &models.QuestionOption{
			QuestionID: quest.ID,
			Title:      v.Title,
			Position:   v.Position,
			IsCorrect:  v.IsCorrect,
			CreatedAt:  time.Now(),
			UpdatedAt:  time.Now(),
		}

		_, err := r.QuestionOptionRepository.CreateQuestionOption(quesOpt)
		if err != nil {
			return &models.Response{
				Message: "Error creating question option",
				Status:  http.StatusInternalServerError,
			}, nil
		}
	}

	return helpers.ResponseDataFormat(quest, "Question")
}

// UpdateQuestion is the resolver for the UpdateQuestion field.
func (r *mutationResolver) UpdateQuestion(ctx context.Context, id string, question models.QuestionInput) (*models.Response, error) {
	gc, _ := helpers.GinContextFromContext(ctx)
	error_handlers.PanicHandler(gc)
	//validate the title:
	if question.Title == "" {
		return &models.Response{
			Message: "The title is required",
			Status:  http.StatusBadRequest,
		}, nil
	}

	//get the question:
	ques, err := r.QuestionRepository.GetQuestionByID(id)
	if err != nil {
		return &models.Response{
			Message: "Error getting the question",
			Status:  http.StatusInternalServerError,
		}, nil
	}

	ques.Title = question.Title
	ques.UpdatedAt = time.Now()

	//save the question:
	quest, err := r.QuestionRepository.UpdateQuestion(ques)
	if err != nil {
		return &models.Response{
			Message: "Error creating question",
			Status:  http.StatusInternalServerError,
		}, nil
	}

	//For the options, we will discard the previous options and insert new ones:
	err = r.QuestionOptionRepository.DeleteQuestionOptionByQuestionID(quest.ID)
	if err != nil {
		return &models.Response{
			Message: "Error Deleting question options",
			Status:  http.StatusInternalServerError,
		}, nil
	}

	for _, v := range question.Options {

		if ok, errorString := helpers.ValidateInputs(*v); !ok {
			return &models.Response{
				Message: errorString,
				Status:  http.StatusUnprocessableEntity,
			}, nil
		}

		quesOpt := &models.QuestionOption{
			QuestionID: quest.ID,
			Title:      v.Title,
			Position:   v.Position,
			IsCorrect:  v.IsCorrect,
			CreatedAt:  time.Now(),
			UpdatedAt:  time.Now(),
		}

		_, err := r.QuestionOptionRepository.CreateQuestionOption(quesOpt)
		if err != nil {
			return &models.Response{
				Message: "Error creating question options",
				Status:  http.StatusInternalServerError,
			}, nil
		}
	}

	return helpers.ResponseDataFormat(quest, "Question")
}

// DeleteQuestion is the resolver for the DeleteQuestion field.
func (r *mutationResolver) DeleteQuestion(ctx context.Context, id string) (*models.Response, error) {
	gc, _ := helpers.GinContextFromContext(ctx)
	error_handlers.PanicHandler(gc)
	err := r.QuestionRepository.DeleteQuestion(id)
	if err != nil {
		return &models.Response{
			Message: "Something went wrong deleting the question.",
			Status:  http.StatusInternalServerError,
		}, nil
	}

	//also delete the options created too:
	err = r.QuestionOptionRepository.DeleteQuestionOptionByQuestionID(id)
	if err != nil {
		return &models.Response{
			Message: "Error Deleting question options",
			Status:  http.StatusInternalServerError,
		}, nil
	}

	return helpers.SuccessResponseFormat()
}

// GetOneQuestion is the resolver for the GetOneQuestion field.
func (r *queryResolver) GetOneQuestion(ctx context.Context, id string) (*models.Response, error) {
	gc, _ := helpers.GinContextFromContext(ctx)
	error_handlers.PanicHandler(gc)
	question, err := r.QuestionRepository.GetQuestionByID(id)
	if err != nil {
		log.Println("getting question error: ", err)
		return &models.Response{
			Message: "Something went wrong getting the question.",
			Status:  http.StatusInternalServerError,
		}, nil
	}

	return helpers.ResponseDataFormat(question, "Question")
}

// GetAllQuestions is the resolver for the GetAllQuestions field.
func (r *queryResolver) GetAllQuestions(ctx context.Context) (*models.ListResponse, error) {

	gc, _ := helpers.GinContextFromContext(ctx)
	error_handlers.PanicHandler(gc)
	questions, err := r.QuestionRepository.GetAllQuestions()
	if err != nil {
		log.Println("getting all questions error: ", err)
		return &models.ListResponse{
			Message: "Something went wrong getting all questions.",
			Status:  http.StatusInternalServerError,
		}, nil
	}

	var data []models.Data
	for _, quest := range questions {
		data = append(data, models.Data(*quest))

	}

	return helpers.ListResponseDataFormat(data, "Questions")
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
